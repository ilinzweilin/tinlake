pragma solidity >=0.5.15. <0.6.0;


import "tinlake-auth/auth.sol";
import "tinlake-math/math.sol";


interface AssessorLike {
    function calcSeniorTokenPrice() external view returns(uint);
    function calcSeniorAssetValue(uint seniorDebt, uint seniorBalance) public pure returns(uint);
    function changeSeniorAsset(uint seniorRatio, uint seniorSupply, uint seniorRedeem) external;
}

interface CordinatorLike {
    function calcSeniorAssetValue(uint seniorRedeem, uint seniorSupply, uint currSeniorAsset, uint reserve_, uint nav_) public pure returns(uint) ;
    function calcSeniorRatio(uint seniorAsset, uint NAV, uint reserve_) public pure returns(uint);
}

interface ReserveLike {
    function totalBalance() external view returns(uint);
    function deposit(uint daiAmount) public;
}

interface NAVFeedLike {
    // TODO: check what better to use approx NAV or current NAV
    function currentNAV() external view returns(uint);
}

interface TrancheLike {
    function mint(address usr, uint amount) public;
}

contract Clerk is Auth, Math {

    uint public expectedRevenue;
    uint public avgDropOut;
    // DAI drawn from the vault not containing accrued interest 
    uint public principalDAI;
    // virtual DAI balance that was already added to the seniorAssetValue, but has not been drawn yet
    uint public balanceDAI;
    // DAI that are drawn from the vault without accrued interest: required for mkr interest calculation
    uint public principalDAI;
    // total DAI value of DROP tokens that are locked as collateral considering the token price on lockup: required for tinlake interest calculation, weighted token price of locked collateral
    uint public DAIForDROP;

    address public mgr;
    address public dai;

    AssessorLike assessor;
    CoordinatorLike coordinator;
    ReserveLike reserve;
    NAVFeedLike nav;
    TrancheLike tranche;

    constructor(address mgr_, address dai_, address assessor_, address coordinator_, address reserve_, address nav_, address tranche_) {
        wards[msg.sender] = 1;
        dai = dai_;
        mgr = mgr_;

        assessor = AssessorLike(assessor_);
        coordinator = CoordinatorLike(coordinator_);
        reserve = ReserveLike(reserve_);
        nav = NAVFeedLike(nav_);
        tranche = TrancheLike(tranche_);
    }

    function join(uint amountDROP) public auth {
        // calculate DAI amount that can be minted considering current DROP token price
        uint amountDAI = rmul(amountDROP, assessor.calcSeniorTokenPrice());

        // TODO: check if the injected DAI liquidity could potentially violate the pool constraints

        // increase balanceDAI, so that the amount can be drawn
        balanceDAI = safeAdd(balanceDAI, amountDAI);
        // increase total DAI value of locked Collateral
        DAIforDROP = safeAdd(DAIForDROP, amountDAI);


        // TODO: make sep function and use in balance
        // increase seniorAssetValue by amountDAI to keep the DROP token price constant 
        uint currenNav = nav.currentNAV();
        uint newSeniorAsset = coordiator.calcSeniorAssetValue(0, amountDAI,
            assessor.calcSeniorAssetValue(assessor.seniorDebt(), assessor.seniorBalance()), reserve.totalBalance(), currenNav);
        uint newSeniorRatio = coordinator.calcSeniorRatio(newSeniorAsset, currenNav, reserve.totalBalance());
        assessor.changeSeniorAsset(newSeniorRatio, amountDAI, 0);
        
        // mint amountDROP & lock in vault
        tranche.mint(address(this), amountDROP);
        mgr.join(d);
    }

    function draw(uint amountDAI) public auth {
        // TODO: maybe find a better condition
        require(reserve.totalBalance() == 0, "Use DAI in reserves first");
        // make sure amount has already been added to the senior balance
        require(amountDAI <= balanceDAI, "Add amount to senior asset first");

        balanceDAI = safeSub(balanceDAI, amountDAI);
        principalDAI = safeAdd(principalDAI, amountDAI);

        // use weighted price here 
        collateralAtWork += rdiv(amountDAI, weightedDropPrice());

        drip();
        expectedRevenue = safeAdd(expectedRevenue, amountDAI);
        
        // draw dai and move to reserve
        mgr.draw(amountDAI);
        dai.approve(address(reserve), amountDAI);
        reserve.deposit(amountDAI);
    }

    function wipe(uint d) public auth {
        // use weighted price here
        collateralAtWork -= d / assessor.calcSeniorTokenPrice();
        // rebalance here again the avg price 
        // should increase balance agaian? because I received the interest already for this amount

        // adjust pricipal DAI

        require(mgr.tab() > 0, "loan already repaid");
        dai.transferFrom(reserve, d);
        drip();
        expectedRevenue = sub(expectedRevenue, d);
        mgr.wipe(d);
    }

    // give the revenue generated by the loans financed by the clerk
    // to the juniors
    function balance(uint wad) public {
        require(mgr.tab() == 0, "Dai loan not paid back");
        drip();
        expectedRevenue = sub(expectedRevenue, wad);
        // decrease seniorBalance by wad.
        // maybe call assessor.rebalance or smth, idk.
    }

    // update revenue/losses of loans financed by the clerk
    function drip() public {

        // uint tinlakeInterest. 
        // -> collateralAtWork / principal = avg price token
        // -> collateral * currentTokenPrice vs accVirtualDaiBalance
        // principal / vault debt --> mkr interest 
        uint makerInterest;
        expectedRevenue = mul(expectedRevenue, sub(tinlakeInterest, makerInterest));
    }

    // remove drop from mkr system
    function exit(uint drop) public auth {
        require(expectedRevenue == 0);
        mgr.exit(drop);
        // remove x from calculation of dropPrice so that price remains constant.
        // (price adjustment happens in `balance`).
        // basically the inverse of join...
    }

    // returns the current rate for the accrued intrest on the DAI drawn from the vault
    function mkrInterest() public returns (uint) {
        // devide vault debt by principalDAI
        return safeDiv(mgr.tab(), pincipalDAI);
    }

    // returns the current senior rate for the accrued intrest on the DROP tokens locked in the vault
    function tinlakeInterest() public return (uint) {
        // TODO: fix call: vat -> urn -> ink
        return safeDiv(rmul(mgr.ink(), assessor.calcSeniorTokenPrice()), DAIforDROP);
    }
    
    // returns the weigthed price per DROP locked in the vault
    function weightedDropPrice() public return (uint) {
        // TODO: fix call: vat -> urn -> ink
        return safeDiv(DAIforDROP, mgr.ink());
    }
}
